#summary Functional Capabilities of URM - Define Codebase
[home] -> [documentation] -> [features] -> [featurescodebase]

Explains how to maintain product codebase using URM.

<wiki:toc max_depth="2" />
----

= Define product codebase =

  * product generally consists of buildable codebase, prebuild binaries, configuration files, database metadata and non-operational data
  * configuration files and database can be treated as special types of codebase
  * buildable codebase is defined in source.xml as a set of projects of "core" category
  * prebuilt binaries are defined in source.xml grouped in projects of "prebuilt" category
  * configuration items are defined in distr.xml
  * database part of product is defined by production instance, concept of URM takes into account that it is practically impossible to track database using engineered DDL scripts; more specifically, URM approach is to make use of continious reverse engineering - with regular PROD snapshots, generating metadata and dumping product data with manual DDL and DML updates in releases

= Define product buildable codebase =

  * before build you need to declare buildable codebase in source.xml as a set of projects
{{{
<source>
<projectset type="core">
  <project name="pgu-portal" vcs="svn" version="branch" jira="PGUDEV">
    <distitem name="gu-web" type="staticwar" path="com/nvision/pgu/portal"/>
    <distitem name="pgu-dependencies" type="nexus" extension="-libs.tar.gz" path="com/nvision/pgu/portal"/>
  </project>
  <project name="sp" vcs="git" version="branch" path="fedpgu" jira="PGUDEV"/>
}}}
  * in URM each project is built as a whole, so you need to plan your codebase structure
  * every project has its own set of tags and branches containing whole project scope
  * project can have below attributes:
{{{
"name" defines reference name and VCS name as well

"vcs" can be git or svn or svnnew
svn/svnnew allow repository migration

"version" can be "branch" or "trunk"
branch means prod status
trunk means non-production codebase - full release build will skip building this project

"path" - in git repository means group, in svn repository means parent path

"branch" defines default production branch

"javaversion" - defines jdk version to use to build this project

"mavenversion" - defines maven version to use to build this project
}}}

= Define product configuration =

  * configuration components are defined in distr.xml as groups of files or directories
{{{
<configuration>
  <component name="tlssrv.conf" subdir="prod" unit="core" type="dir" layer="server"/>
  <component name="tlssrv.new.conf" subdir="prod" unit="core" type="dir" layer="server"/>
  <component name="nlb.conf" subdir="prod" unit="core" type="dir" layer="server"/>
  <component name="dev.nlb.conf" subdir="dev" unit="core" type="dir" layer="server"/>
  <component name="jms.conf" subdir="prod" unit="core" type="files" files="hornetq-configuration.xml 
hornetq-jms.xml hornetq-users.xml logging.properties" layer="server"/>
  <component name="xuat.jms.conf" subdir="dev" unit="core" type="files" files="hornetq-configuration.xml 
hornetq-jms.xml hornetq-users.xml logging.properties" layer="server"/>
}}}
  * configuration components currently in PROD are located in svn in repository defined by variable in config.sh:
{{{
C_CONFIG_SOURCE_CFG_ROOTDIR=$C_CONFIG_SVNOLD_PATH/releases/$C_CONFIG_PRODUCT/configuration
}}}

= Define product database =
= Define and upload prebuilt items =

= Using git repositories =

  * to build codebase stored in git hubs URM utilizes approach of mirror repository, with automatic push and pull on each URM operation
  * mirror git repositories are located in directory defined in config.sh:
{{{
C_CONFIG_GITMIRRORPATH=~/build/git
}}}
  * sample code to create git mirror:
{{{
#!/bin/sh

P_GROUP=$1
P_PROJECT=$2

if [ "$P_GROUP" = "" ]; then
        echo P_GROUP is not set. Exiting
        exit 1
fi
if [ "$P_PROJECT" = "" ]; then
        echo P_PROJECT is not set. Exiting
        exit 1
fi

F_GIT_SOURCE=http://builder@mygit.com/$P_GROUP/$P_PROJECT.git
F_GIT_MIRROR=/build/git/$P_PROJECT.git

echo create mirror from git central repository $F_GIT_SOURCE to local $F_GIT_MIRROR
rm -rf $F_GIT_MIRROR
git clone --mirror $F_GIT_SOURCE $F_GIT_MIRROR

echo mirror.sh: successfully done
}}}
  * to persist auth attributes - execute below commands:
{{{
git config --global credential.helper "cache --timeout=100000000"
git config --global user.email myname@mycompany.com
git config --global user.name builder

after that mirror will ask password once and stores it in current account
}}}