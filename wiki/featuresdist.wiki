#summary Functional Capabilities of URM - Distributive Management
[home] -> [documentation] -> [features] -> [featuresdist]

Explains how to create and maintain distributives using URM.

<wiki:toc max_depth="2" />
----

= Define distributive items =

  * all possible binary and configuration distributive items are defined in distr.xml
  * distr.xml file split items on categories, arranges them in groups, defines names, defines versioning approach and enables to store binary items in separate folders
  * see Define Codebase to understand product configuration and Prepare and Apply Database Changes to understand database items in distributive
  * built binary items disregarding of whether they are built or prebuilt, are defined in the same section
{{{
<module>
  <distributive>
    <binary-list>
      <!-- carcass binaries -->
      <distitem name="frgu-integration-ws" type="binary" extension=".war" deployversion="midpound"/>
...
      <distitem name="log4j-1.2.16" type="binary" extension=".jar" deployversion="none"/>
...

in fact you can have no source.xml data at all and prepare distributive manually
}}}
  * for the purpose of deployment, binary items are grouped in deployment components
{{{
<module>
	<deployment-binaries>
		<component name="pguweb.fedwar" unit="core">
			<distitem name="fms-web"/>
			<distitem name="pfr-web"/>
			<distitem name="rosreestr-web"/>
			<distitem name="pgu-fed-web"/>
			<distitem name="pgu-poltava-web"/>
		</component>

one binary distributive item can be part of several deployment components
see see Application Deployment for further details
}}}
  * binary distributive item has below attributes:
{{{
"name" - reference name, to use in deployment components, source.xml, release.xml

"type" - binary, war, archive.direct, archive.subdir, archive.child
- binary: one file in distributive copied to one file in environment
- war: 2 files - web application and its static stored separately and deployed to another server
- archive.direct: archive content is full content of deployment location
- archive.subdir: archive content is full content of subfolder of deployment location
subdir name is equal to archive basename
- archive.child: archive contains one folder named by archive basename
should be deployed to corresponding subfolder of deployment location 

"obsolete" - applicable only for refactoring-aligned environments and releases
- e.g.:
<release>
	<property name="obsolete" value="false"/>

"distname" - if reference name differs from basename of filename then you need to specify distname
- e.g.:
<distitem name="privateoffice-ear" type="binary" extension=".ear" distname="privateoffice"/>
<distitem name="privateoffice-war" type="binary" extension=".war" distname="privateoffice"/>

"folder" - item is located in distibutive in corresponding subfolder 
- e.g.:
<distitem name="ojdbc6" type="binary" extension=".jar" folder="thirdparty"/>
will lead to file path - $DISTPATH/thirdparty/ojdbc6.jar

"deployname" - distributive item basename will be changed in environment to specified value

"deployversion" - defines how to add version information
- see Application Deployment for details

"extension" - defines extention, including all characters after basename excluding version
- e.g.:
<distitem name="backend-pg" type="binary" extension=".war"/>
<distitem name="frgu-integration-groovy" type="archive.direct" extension="-groovy.tar.gz"/>
}}}

= Release planning and updates =

  * release planning is performed using release specification file release.xml located in distributive folder
  * release.xml defines components included in release
  * create distributive folder and release.xml manually
  * example of release definition aimed to build and deploy all binaries and configuration:
{{{
<release>
	<build>
		<buildset type="core" all="true"/>
		<buildset type="prebuilt" all="true"/>
	</build>

	<configure all="true"/>
</release>
}}}
  * more specific incremental release can limit projects and components included:
{{{
<release>
	<build>
		<buildset type="core">
			<project name="pgu-paygate"/>
			<project name="pgu-portal"/>
			<project name="pgu-forms-core-front"/>
			<project name="pgu-forms-svc"/>
			<project name="sp"/>
			<project name="pgu-forms-core-back"/>
			<project name="bem"/>
			<project name="pgu-core">
				<distitem name="smev-lk-service"/>
				<distitem name="drafts"/>
				<distitem name="pgu-worker"/>
			</project>
		</buildset>

		<buildset type="prebuilt">
                        <project name="carcass" buildversion="3.12">
         	                <distitem name="frgu-integration-inc"/>
         	                <distitem name="frgu-integration-groovy"/>
                        </project>
		</buildset>
	</build>

        <configure>
                <component partial="true" name="serviceregistry.settings.conf"/>
                <component partial="true" name="jms.conf"/>
        </configure>
</release>

Last example means:
- building project pgu-portal and deploying all its registered binaries
- building project pgu-core and deploying only listed 3 binaries
- downloading 2 listed prebuild dependency binaries

Configure:
- download and deploy 2 configuration components - only present in release repository
}}}
  * if you need to update release scope and make additional build, you need to keep in mind dependencies and hidden rules:
{{{
your incremental build is affected by previous builds
if you increase the scope and performing full release build it does not cause any problems

if you reduce release scope then you need to rebuild descoped projects by production tag
then you need to rebuild new release scope
it is recommended to mark descoped items by changing elements to descopedproject, descopeddistitem
do not delete anything from release.xml after build

if you have increased release scope you can run limited build only according to dependencies
}}}

= Prepare binary updates =

  * normally codebase update means regenerating related binary files and deploying these files to production environment
  * practically there are cases where some binaries have to be changed due to codebase change are not part of specific release; also there are  cases when release item is updated in one location of production environment and and stays the same in another production location
  * whatever situation is in place you need to understand what and why should be changed, and define it in deployment plan; default URM behavior will lead to normal scenario
{{{
for default scenario add projects which have planned update according to release planning
		<buildset type="core">
			<project name="pgu-paygate"/>
this means that all binaries defined in source.xml are included in release
see also Build Projects for details on modifying tags and branches to be built if required

if you have some project required to be built but you know that not all of its binaries are in release - 
then specify exactly what binaries should be included in release
		<buildset type="core">
			<project name="pgu-core">
				<distitem name="smev-lk-service"/>
				<distitem name="drafts"/>
				<distitem name="pgu-worker"/>
			</project>

see Application Deployment for details on how to limit deployment
}}}
  * to download items:
{{{
to download all items:
./getall.sh

to download all core non-release items:
./getall.sh core

to download all prebuilt non-release items:
./getall.sh prebuilt

to download binaries of selected proejcts:
./getall.sh core project1 project1
./getall.sh prebuilt project3 project4

to download next planned release binaries without affecting distributive folder:
./getall-release.sh ...
use the same parameters as for getall.sh
items will be downloaded to folder defined in config.sh
C_CONFIG_ARTEFACTDIR=~/build/artefacts/$C_CONFIG_PRODUCT

to download specific release binaries without affecting distributive folder:
./getall-release.sh -release 1.2.3 ...

to download next planned release binaries and copy to distributive folder:
./getall-release.sh -dist ...
}}}

= Prepare configuration updates =

  * TBD

= Prepare database updates =

  * TBD