#summary Functional Capabilities of URM - Copying Files to Environment
[home] -> [documentation] -> [features] -> [featuresredist]

Defines process of relocation of files to environment.

<wiki:toc max_depth="2" />
----

= Local and remove distributives =

  * generally there are distribution host, deployment host and environment host which participate in operation
  * distributives are given from filesystem path defined in environment specification path, remote or local

{{{
Environment specification file $PRODUCT_DEPLOYMENT_HOME/etc/env/<env>.xml defines one of two possible distributive locations:

1. Local on deployment host:
	<property name="distr-use-local" value="true"/>
	<property name="distr-path" value="/distr/pgu"/>

- copy is performed by scp from local directory to environment host
- configuration files are copied as archive

2. Remote, from separate distributive box:
	<property name="distr-use-local" value="false"/>
	<property name="distr-remotehost" value="release-mgn@192.168.100.29"/>

- copy release definition file
- copy distributive files from distributive box to deployment box and then to environment host
}}}

= Staging area =

  * to handle network copy risks and to reduce downtime required, deployment is performed in two steps:
   * intially distributive is copied to environment hosts, to staging area folders, without affecting running processes
   * when all files are relocated to staging area, actual deployment can be executed, with affecting runtime area

{{{
Product parameter file defines location of staging area for all hosts on all environments:
	C_CONFIG_REDISTPATH=/oracle/d/redist

Command ./redist.sh relocates files from distributive to staging area subdirectory - $C_CONFIG_REDISTPATH/<server>/<release>
- $C_CONFIG_REDISTPATH should be created on initial setup of environment
- staging area directory stores all releases for all servers hosted there
- copy is performed using server user, that's why $C_CONFIG_REDISTPATH better should be chmod 777
- to cleanup stanging area, use command ./dropredist.sh

Stanging area release folder content:
- deploy[/<location>]/<binary file>
- config[/<location>]/<config component>.tar
- hotdeploy[/<location>]/<binary file>
- hotdeploy/config/[/<location>]/<config component>.tar

rollout.sh command performs relocation from staging area to environment runtime location.
In hotdeploy mode rollout executes hotdeploy command.
}}}

= Automatic binary file renaming =

  * distributive and environment files can have different names
  * reason is having different basename or adding versioning prefix

{{{
release directory name format is <releasever>[-<distname>], where
	<releasever> - version corresponding to tag set on source code files
	<distname> - can be used to support several distributives for the same version (e.g. cumulative and incremental)

Environment file name is [<releasever>-]<deployname><extension>, where
	<releasever> - release directory version
		- setting version can be skipped if distributive item has below property in distributive specification file:
			<distitem name="axis" type="binary" extension=".jar" options="N"/>
	<deployname> - binary file basename

In release directory binary file is usually named <distname>-<majorversion><extension>, where
	<distname> - binary file basename in distributive, can be different from built basename, if required:
			<distitem name="ojdbc.jar" type="binary" distname="ojdbc6-11.2.0.1.0" extension=".jar"
					deployname="ojdbc6" options="N"/>
		<majorversion> - major release version, e.g. in messagelog-1.13.ear - is 1.13, while release version is 1.13.14

If versioning is not turned off, environment file will be renamed:
	from <distname>-<majorversion><extension> to <releasever>-<deployname><extension>
}}}

= Partial deployments, using "-unit" option =

  * in some cases, one may need to have partial deployment
  * one way to to deploy by giving server list in command line
  * another way is to use "-unit" option, which filters distributive selecting only items, related to specific unit

{{{
To deploy only specified servers, execute commands:
	./redist.sh <release> <server1> <server2> ... <serverN>
	./deployredist.sh <release> <server1> <server2> ... <serverN>

Note:
- command ./redist.sh if servers are specified, does not change other server staging area, except static servers
- dist item of type "war" (see. distr.xml) causes automatic redist to static server, defined in environment specification file:
		<server name="formweb" type="generic.web"
			proxy-server="formweb.nginx"
			...
		here ./redist.sh <release> formweb automatically copies static archives to formweb.nginx

- ./deployredist.sh command use only servers defined in parameters or all servers with non-empty staging area:
		т.е. ./deployredist.sh <release> formweb will not change formweb.nginx

Option "-unit <unitname>" limits scope of ./redist.sh command:
- only components being part of specified unit are copied to destination servers, see distributive specification file:
		<component name="formweb.conf" 			unit="core" type="files" files="run.pguweb.conf" layer="server"/>

		<component name="pguweb.regcommon" unit="core">
			<distitem name="cms-public-web"/>
			<distitem name="gu-web"/>
			<distitem name="pgu-paygate-web"/>
			<distitem name="pgu-temp-web"/>
			<distitem name="pgu-forms-executor"/>
		</component>

       		<!-- regional webs -->
		<component name="pguweb.reg.01" unit="K7">
			<distitem name="pgu-reg101-web"/>

       		here ./redist.sh -unit K7 will not copy formweb.conf and pguweb.regcommon

- ./deployredist.sh command rolls out all staging area, disregarding of "-unit" option
}}}

= Safe copy over network =

  * files copied over network may become corrupted due to network failure
  * to ensure safe releases after copying to staging area file is automatically verified

{{{
Before copy and after copy md5sum is calculated vs file.
If values are different, redist.sh scripts informs about problem and cancels its work.
Just run redist.sh again or resolve network issue
}}}

= Multiple server locations =

  * simple deployment is using single location on host filesystem to roll out release files
  * practically most servers require several directories where distributive files should be placed to

{{{
Every server in environment specification file has root path.
		<server name="osb" type="generic.server" deploytype="default"
			rootpath="/oracle"
- root path prevents from affecting anything else in operating system
- do not use "/" directory for root path

Component can have deploy path different from default.
Every defined path for the server is named "deployment location".
- location is relative to root path.
- server can have default deployment location:
		<server name="owsm" type="generic.server" deploytype="default"
			deploypath="ora_app1/as10g/owsm/lib/custom"

- every component can use default location of specify its own:
		<server name="osb" type="generic.server" deploytype="default"
			deploypath="build/osb.deploy"
			...
			<deploy component="osb"/>
			<deploy component="osb.xquery" deploypath="osb/Oracle_OSB/config/xpath-functions" />

- all component files, as specified in distributive specification file, are rolled out to its deployment location
- several components of the same hot/cold type can use the same location
- configuration component or archive can have subfolders as its content, that will be created in location directory

Sometimes locations do not have common root path, except "/"
- then it is recommended to create soft link:
	ln -s <real directory path> <server root path>/<virtual location>, где
		<real directory path> - path usexd by server process 
		<server root path> - server root path
		<virtual location> - synthetic location for URM
}}}

= Archive deployment =

  * archives which need to be copied to runtime without extracting files, are regarded by URM as binaries
  * if you need to automatically extract archive, then you need to define distributive item as archive

{{{
Distributive specification file distr.xml can reference archive as one of - "archive.direct", "archive.child", "archive.subdir":
	e.g., <distitem name="pgu-dependencies" distname="pgu-dependencies" type="archive.direct" extension="-libs.tar.gz"/>

Ditrributive item is then included to the component as usual:
		<component name="pguweb.dependencies" unit="core">
			<distitem name="pgu-dependencies"/>
		</component>

In environment specification file component can assign specific deployment location:
		<server name="fedweb" type="generic.web"
			...
			<deploy component="pguweb.dependencies" deploypath="jboss/server/default/lib"/>

Archive type defines how deployment location is treated for archive:
- archive.direct means that deployment location contains archive content and nothing all
- archive.child means that archive contains single directory equal to archive basename, 
which should be subdirectory in deployment location
- archive.subdir means that deployment location should have subdirectory equal to archive basename and
this subdirectory will contain archive contents
}}}

= Deployment of configuration files =

  * configuration files are usually flat files allowing to view and edit them in the environment
  * release can introduce certain configuration files changes which URM can deploy to the environment
  * configuration files can be fully specified in release or can be template files
  * template files reference parameters defined elsewhere

{{{
URM will deploy configuration files ony if environment specification file has property:
	<property name="configuration-deploy" value="yes"/>

- product parameter file should have:
C_CONFIG_USE_TEMPLATES=yes

- redist.sh operation sets variables to templates when copying files from distributive to staging area
- variables are defined in environmet specification file
- before rolling out these files one can check validity of substitution
- alternatively one can run ./configure.sh to generate configuration file set locally
- last requires correct merge of release change to the full configuration set:
	$C_CONFIG_SOURCE_CFG_ROOTDIR/templates

redist.sh copies cold-deployed configuration archive to:
	<redist dir>/<server>/<releasedir>/config/[/<location>]/<component>.config.tar
- then rollout.sh extracts this archive to
	<server root dir>/<location>

hot-deployed configuration archive is copied to:
	<redist dir>/<server>/<releasedir>/hotdeploy/config/[/<location>]/<component>.config.tar
- then rollout.sh copies this archive to below dir and executes hot deploy command
	<server root dir>/<hotdeploydir>/<location>

Binaries can be deployed without changing configuration, by using:
	./redist.sh -noconf <release> ...

Otherwise, one can deploy only configuration files:
	./redist.sh -nobinary -conf <release> ...

Even if environment property is set to ignore configuration files, one can override this by using explicit option:
	./redist.sh -conf <release> ...
	./deployredist.sh -conf <release> ...
}}}

= Save and restore overall configuration =

  * environment configuration files can be saved in svn and restored from templates
  * all of the defined configuration components are updated

{{{
Configurations files are referenced in configuration components in distr.xml
- server configuration components are defined in environment specification file:
		<server name="pguapp" type="generic.server"
			...
			>
			...
			<configure component="commonapp.p6spy.conf" deploypath="jboss/server/default/conf"/>
			<configure component="pguapp.cryptopro.ca" deploypath="jboss_keys/ECPrOVrP.TEST"/>
			<configure component="pguapp.app.conf" deploypath="jboss/server/default/conf/pgu"/>
			<configure component="pguapp.config.ds" deploypath="jboss/server/default/deploy"/>

- mapping component to files is defined in distributive specification file:
			<component name="pguapp.cryptopro.ca" 		unit="core" type="dir" layer="server"/>
			<component name="pguapp.app.conf" 		unit="core" type="dir" layer="server"/>
			<component name="pguapp.jbossweb-sar.conf" 	unit="core" type="files" files="server.xml" layer="server"/>

Environment configuration files are stored in $C_CONFIG_SOURCE_CFG_LIVEROOTDIR/<env> by calling:
	./svnsaveconfig.sh

Still, files are restored from template directory $C_CONFIG_SOURCE_CFG_ROOTDIR/templates by calling:
	./svnrestoreconfig.sh

- note, that svnrestoreconfig does not stop or start any server, so please execute them manually when required
- currently, restore of hotdeploy configuration is not supported
}}}

= nginx static files deployment =

  * war-files for web-applications can be separated in distributive from static data - one war file and one related static file
  * useful design is when static files are returned to browser immediately from filesystem, without querying application server
  * static file can be rolled out using archive approach but another way is to use special distributive item type

{{{
War-file with static is defined in distr.xml:
			<distitem name="gu-web" type="war" context="pgu"/>

Then this item is included to component as usual:
		<component name="pguweb.fedcore" unit="core">
			<distitem name="pgu-esperanto-web"/>
			...

Environment specification file references war item also like ordinary binary item:
		<server name="fedweb" type="generic.web"
			...
			proxy-server="fedweb.nginx"
			>
			<deploy component="pguweb.fedcore"/>
			...
- but if server has proxy-server attribute defined then proxy-server will be target for the static:
		<server name="fedweb.nginx" type="service" servicename="nginx"
			starttime="30"
			port="3010"
			rootpath="/oracle/ora_app2"
			deploypath="nginx/html"
			webdomain="feddemo1.gosuslugi.ru"
			>
			<node hostlogin="root@172.20.15.40"/>
			<node hostlogin="root@172.20.15.65"/>
			<configure component="pguweb.nginx.conf" deploypath="nginx/etc/nginx"/>
			<configure component="commonweb.nginx.htmlroot" deploypath="nginx/html"/>
			<configure component="commonweb.nginx.static-errors" deploypath="nginx/html/static_errors"/>
		</server>
- proxy-server will be target for deployment but its definition does not contain deployments
- root path and default deployment location from proxy-server are used to roll out static
- static archive type expected - "archive.subdir"

redist.sh command when deploying to web application server automatically copies static archives to proxy-server:
- subsequent rollout using deployredist.sh will deploy static archives
- if deployredist.sh is executed giving only web app server as a parameter, proxy-server will not be updated
- it is assumed that proxy-server has the same numebr of nodes as web application server
}}}

= Backup and rollack =

  * standard approach to recover from bad release is rollback to previous distribution
  * URM support automated rollback

{{{
Rollbacks files are created in staging area if using option "-backup" in redist.sh.
Option can be set as default by defining property in environment specification file:
	<property name="backup" value="yes"/>

redist.sh gets rollback files from runtime area of the same host and copied to:
	$C_CONFIG_REDISTPATH/<server>/<release>-backup

Rollback operation automatically deletes previous version if any:
- files deleted are <any version>-<basename><extension>, <basename>-<any version><extension>, <basename><extension>
- if file was not found in the environment, URM issues warning but continues execution
- if there are several files with the same basename, it is regarded as error and operation is canceled

Files are restored from rollback directory in staging area:
- configuration component rollback files can differ from release ones if files are defined using mask
- to support rollback of hotdeploy files rollout.sh logic copies files to deploypath where files are not used by process but persisted

Release rollback is partially manual because of unpredictable reasons:
- rollback.sh command restores in runtime area files saved by redist.sh in rollback directory of staging area
- "rollback.sh -cold" rolls out cold-components, "rollback.sh -hot" - hotdeploy-components
- you may need to run start/stop servers to finish rollback
- possible "clear" rollback after unsuccessful release X.Y.Z can be achieved by:
	./stopenv.sh
	./rollback.sh -cold X.Y.Z
	./startenv.sh
	./rollback.sh -hot X.Y.Z
}}}
